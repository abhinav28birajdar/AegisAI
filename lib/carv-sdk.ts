// CARV Protocol SDK Integration
// This module handles CARV ID authentication and data sovereignty

import { createPublicClient, createWalletClient, custom, http } from 'viem'
import { polygon, polygonMumbai } from 'viem/chains'

// CARV SDK Types
export interface CarvProfile {
  carv_id: string
  wallet_address: string
  verifiable_credentials: CarvCredential[]
  data_sharing_consents: DataSharingConsent[]
  reputation_score: number
  is_verified: boolean
}

export interface CarvCredential {
  id: string
  type: string
  issuer: string
  issued_date: string
  expiry_date?: string
  credential_data: any
  verification_status: 'verified' | 'pending' | 'revoked'
}

export interface DataSharingConsent {
  data_type: string
  consent_level: 'none' | 'anonymized' | 'aggregated' | 'full'
  purpose: string
  expiry_date?: string
  consent_signature: string
}

export interface CarvAuthResult {
  success: boolean
  carv_id?: string
  wallet_address?: string
  signature?: string
  error?: string
}

class CarvSDK {
  private static instance: CarvSDK
  private isInitialized = false
  private currentProfile: CarvProfile | null = null

  public static getInstance(): CarvSDK {
    if (!CarvSDK.instance) {
      CarvSDK.instance = new CarvSDK()
    }
    return CarvSDK.instance
  }

  async initialize() {
    if (this.isInitialized) return

    try {
      // Initialize CARV Protocol connection
      // This would normally connect to CARV's infrastructure
      console.log('Initializing CARV SDK...')
      this.isInitialized = true
    } catch (error) {
      console.error('Failed to initialize CARV SDK:', error)
      throw error
    }
  }

  async authenticateWithCarv(): Promise<CarvAuthResult> {
    try {
      if (!this.isInitialized) {
        await this.initialize()
      }

      // Check if wallet is available
      if (typeof window === 'undefined' || !window.ethereum) {
        return {
          success: false,
          error: 'No Web3 wallet detected. Please install MetaMask or another compatible wallet.'
        }
      }

      // Request wallet connection
      const accounts = await window.ethereum.request({
        method: 'eth_requestAccounts'
      })

      if (!accounts || accounts.length === 0) {
        return {
          success: false,
          error: 'No wallet accounts available'
        }
      }

      const walletAddress = accounts[0]

      // Create wallet client
      const walletClient = createWalletClient({
        chain: process.env.NODE_ENV === 'production' ? polygon : polygonMumbai,
        transport: custom(window.ethereum)
      })

      // Generate CARV ID authentication message
      const message = `Sign this message to authenticate with CARV ID.
        
Wallet: ${walletAddress}
Timestamp: ${Date.now()}
Platform: CivicChain
        
This signature will be used to verify your identity and create your CARV ID.`

      // Request signature
      const signature = await walletClient.signMessage({
        account: walletAddress as `0x${string}`,
        message
      })

      // Generate CARV ID (normally this would be done by CARV Protocol)
      const carvId = this.generateCarvId(walletAddress, signature)

      // Create/update CARV profile
      await this.createOrUpdateProfile(carvId, walletAddress, signature)

      return {
        success: true,
        carv_id: carvId,
        wallet_address: walletAddress,
        signature
      }

    } catch (error) {
      console.error('CARV authentication failed:', error)
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Authentication failed'
      }
    }
  }

  private generateCarvId(walletAddress: string, signature: string): string {
    // In a real implementation, this would be generated by CARV Protocol
    // For now, we'll create a deterministic ID based on wallet and signature
    const hash = this.simpleHash(walletAddress + signature)
    return `carv_${hash.substring(0, 16)}`
  }

  private simpleHash(input: string): string {
    let hash = 0
    for (let i = 0; i < input.length; i++) {
      const char = input.charCodeAt(i)
      hash = ((hash << 5) - hash) + char
      hash = hash & hash // Convert to 32-bit integer
    }
    return Math.abs(hash).toString(16)
  }

  private async createOrUpdateProfile(carvId: string, walletAddress: string, signature: string) {
    // Store CARV profile data
    this.currentProfile = {
      carv_id: carvId,
      wallet_address: walletAddress,
      verifiable_credentials: [],
      data_sharing_consents: [],
      reputation_score: 0,
      is_verified: true
    }

    // Store in localStorage for persistence
    if (typeof window !== 'undefined') {
      localStorage.setItem('carv_profile', JSON.stringify(this.currentProfile))
      localStorage.setItem('carv_signature', signature)
    }
  }

  async getCurrentProfile(): Promise<CarvProfile | null> {
    if (this.currentProfile) {
      return this.currentProfile
    }

    // Try to load from localStorage
    if (typeof window !== 'undefined') {
      const stored = localStorage.getItem('carv_profile')
      if (stored) {
        this.currentProfile = JSON.parse(stored)
        return this.currentProfile
      }
    }

    return null
  }

  async updateDataSharingConsent(dataType: string, consentLevel: DataSharingConsent['consent_level'], purpose: string): Promise<boolean> {
    try {
      if (!this.currentProfile) {
        throw new Error('No CARV profile found')
      }

      const existingIndex = this.currentProfile.data_sharing_consents.findIndex(
        consent => consent.data_type === dataType && consent.purpose === purpose
      )

      const newConsent: DataSharingConsent = {
        data_type: dataType,
        consent_level: consentLevel,
        purpose,
        expiry_date: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString(), // 1 year
        consent_signature: `consent_${Date.now()}_${this.simpleHash(dataType + purpose)}`
      }

      if (existingIndex >= 0) {
        this.currentProfile.data_sharing_consents[existingIndex] = newConsent
      } else {
        this.currentProfile.data_sharing_consents.push(newConsent)
      }

      // Update localStorage
      if (typeof window !== 'undefined') {
        localStorage.setItem('carv_profile', JSON.stringify(this.currentProfile))
      }

      // In a real implementation, this would update CARV Protocol
      return true
    } catch (error) {
      console.error('Failed to update data sharing consent:', error)
      return false
    }
  }

  async issueVerifiableCredential(type: string, issuer: string, credentialData: any): Promise<CarvCredential | null> {
    try {
      if (!this.currentProfile) {
        throw new Error('No CARV profile found')
      }

      const credential: CarvCredential = {
        id: `vc_${Date.now()}_${this.simpleHash(type + issuer)}`,
        type,
        issuer,
        issued_date: new Date().toISOString(),
        credential_data: credentialData,
        verification_status: 'verified'
      }

      this.currentProfile.verifiable_credentials.push(credential)

      // Update localStorage
      if (typeof window !== 'undefined') {
        localStorage.setItem('carv_profile', JSON.stringify(this.currentProfile))
      }

      return credential
    } catch (error) {
      console.error('Failed to issue verifiable credential:', error)
      return null
    }
  }

  async logout(): Promise<void> {
    this.currentProfile = null
    if (typeof window !== 'undefined') {
      localStorage.removeItem('carv_profile')
      localStorage.removeItem('carv_signature')
    }
  }

  // Data sovereignty methods
  async getDataContributions(): Promise<any[]> {
    // This would fetch user's data contributions from CARV Data Protocol
    return []
  }

  async contributeData(dataType: string, data: any, consentLevel: DataSharingConsent['consent_level']): Promise<boolean> {
    try {
      // Verify user consent
      const hasConsent = this.currentProfile?.data_sharing_consents.some(
        consent => consent.data_type === dataType && consent.consent_level !== 'none'
      )

      if (!hasConsent) {
        throw new Error('No consent found for this data type')
      }

      // In a real implementation, this would submit to CARV Data Protocol
      console.log('Contributing data to CARV Protocol:', { dataType, consentLevel })
      return true
    } catch (error) {
      console.error('Failed to contribute data:', error)
      return false
    }
  }
}

// Global instance
export const carvSDK = CarvSDK.getInstance()

// React hooks for CARV integration
export const useCarvAuth = () => {
  const [isAuthenticated, setIsAuthenticated] = React.useState(false)
  const [profile, setProfile] = React.useState<CarvProfile | null>(null)
  const [loading, setLoading] = React.useState(true)

  React.useEffect(() => {
    const checkAuth = async () => {
      try {
        const currentProfile = await carvSDK.getCurrentProfile()
        setProfile(currentProfile)
        setIsAuthenticated(!!currentProfile)
      } catch (error) {
        console.error('Failed to check CARV auth:', error)
      } finally {
        setLoading(false)
      }
    }

    checkAuth()
  }, [])

  const login = async () => {
    setLoading(true)
    try {
      const result = await carvSDK.authenticateWithCarv()
      if (result.success) {
        const newProfile = await carvSDK.getCurrentProfile()
        setProfile(newProfile)
        setIsAuthenticated(true)
        return result
      }
      return result
    } finally {
      setLoading(false)
    }
  }

  const logout = async () => {
    await carvSDK.logout()
    setProfile(null)
    setIsAuthenticated(false)
  }

  return {
    isAuthenticated,
    profile,
    loading,
    login,
    logout
  }
}

// Import React for hooks
import React from 'react'

export default carvSDK
