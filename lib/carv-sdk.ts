// CARV Protocol SDK Integration
// This module handles CARV ID authentication and data sovereignty

import { createPublicClient, createWalletClient, custom, http } from 'viem'
import { polygon, polygonMumbai } from 'viem/chains'

// CARV SDK Types
export interface CarvProfile {
  carv_id: string
  wallet_address: string
  verifiable_credentials: CarvCredential[]
  data_sharing_consents: DataSharingConsent[]
  reputation_score: number
  is_verified: boolean
}

export interface CarvCredential {
  id: string
  type: string
  issuer: string
  issued_date: string
  expiry_date?: string
  credential_data: any
  verification_status: 'verified' | 'pending' | 'revoked'
}

export interface DataSharingConsent {
  data_type: string
  consent_level: 'none' | 'anonymized' | 'aggregated' | 'full'
  purpose: string
  expiry_date?: string
  consent_signature: string
}

export interface CarvAuthResult {
  success: boolean
  carv_id?: string
  wallet_address?: string
  signature?: string
  error?: string
}

class CarvSDK {
  private static instance: CarvSDK
  private isInitialized = false
  private currentProfile: CarvProfile | null = null

  public static getInstance(): CarvSDK {
    if (!CarvSDK.instance) {
      CarvSDK.instance = new CarvSDK()
    }
    return CarvSDK.instance
  }

  async initialize() {
    if (this.isInitialized) return

    try {
      // Initialize CARV Protocol connection
      // This would normally connect to CARV's infrastructure
      console.log('Initializing CARV SDK...')
      this.isInitialized = true
    } catch (error) {
      console.error('Failed to initialize CARV SDK:', error)
      throw error
    }
  }

  async authenticateWithCarv(): Promise<CarvAuthResult> {
    try {
      if (!this.isInitialized) {
        await this.initialize()
      }

      // Check if wallet is available
      if (typeof window === 'undefined' || !window.ethereum) {
        return {
          success: false,
          error: 'No Web3 wallet detected. Please install MetaMask or another compatible wallet.'
        }
      }

      // Request wallet connection
      const accounts = await window.ethereum.request({
        method: 'eth_requestAccounts'
      })

      if (!accounts || accounts.length === 0) {
        return {
          success: false,
          error: 'No wallet accounts available'
        }
      }

      const walletAddress = accounts[0]

      // Create wallet client
      const walletClient = createWalletClient({
        chain: process.env.NODE_ENV === 'production' ? polygon : polygonMumbai,
        transport: custom(window.ethereum)
      })

      // Generate CARV ID authentication message
      const message = `Sign this message to authenticate with CARV ID.
        
Wallet: ${walletAddress}
Timestamp: ${Date.now()}
Platform: CivicChain
        
This signature will be used to verify your identity and create your CARV ID.`

      // Request signature
      const signature = await walletClient.signMessage({
        account: walletAddress as `0x${string}`,
        message
      })

      // Generate CARV ID (normally this would be done by CARV Protocol)
      const carvId = this.generateCarvId(walletAddress, signature)

      // Create/update CARV profile
      await this.createOrUpdateProfile(carvId, walletAddress, signature)

      return {
        success: true,
        carv_id: carvId,
        wallet_address: walletAddress,
        signature
      }

    } catch (error) {
      console.error('CARV authentication failed:', error)
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Authentication failed'
      }
    }
  }

  private generateCarvId(walletAddress: string, signature: string): string {
    // In a real implementation, this would be generated by CARV Protocol
    // For now, we'll create a deterministic ID based on wallet and signature
    const hash = this.simpleHash(walletAddress + signature)
    return `carv_${hash.substring(0, 16)}`
  }

  private simpleHash(input: string): string {
    let hash = 0
    for (let i = 0; i < input.length; i++) {
      const char = input.charCodeAt(i)
      hash = ((hash << 5) - hash) + char
      hash = hash & hash // Convert to 32-bit integer
    }
    return Math.abs(hash).toString(16)
  }

  private async createOrUpdateProfile(carvId: string, walletAddress: string, signature: string) {
    // Store CARV profile data
    this.currentProfile = {
      carv_id: carvId,
      wallet_address: walletAddress,
      verifiable_credentials: [],
      data_sharing_consents: [],
      reputation_score: 0,
      is_verified: true
    }

    // Store in localStorage for persistence
    if (typeof window !== 'undefined') {
      localStorage.setItem('carv_profile', JSON.stringify(this.currentProfile))
      localStorage.setItem('carv_signature', signature)
    }
  }

  async getCurrentProfile(): Promise<CarvProfile | null> {
    if (this.currentProfile) {
      return this.currentProfile
    }

    // Try to load from localStorage
    if (typeof window !== 'undefined') {
      const stored = localStorage.getItem('carv_profile')
      if (stored) {
        this.currentProfile = JSON.parse(stored)
        return this.currentProfile
      }
    }

    return null
  }

  async updateDataSharingConsent(dataType: string, consentLevel: DataSharingConsent['consent_level'], purpose: string): Promise<boolean> {
    try {
      if (!this.currentProfile) {
        throw new Error('No CARV profile found')
      }

      const existingIndex = this.currentProfile.data_sharing_consents.findIndex(
        consent => consent.data_type === dataType && consent.purpose === purpose
      )

      const newConsent: DataSharingConsent = {
        data_type: dataType,
        consent_level: consentLevel,
        purpose,
        expiry_date: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString(), // 1 year
        consent_signature: `consent_${Date.now()}_${this.simpleHash(dataType + purpose)}`
      }

      if (existingIndex >= 0) {
        this.currentProfile.data_sharing_consents[existingIndex] = newConsent
      } else {
        this.currentProfile.data_sharing_consents.push(newConsent)
      }

      // Update localStorage
      if (typeof window !== 'undefined') {
        localStorage.setItem('carv_profile', JSON.stringify(this.currentProfile))
      }

      // In a real implementation, this would update CARV Protocol
      return true
    } catch (error) {
      console.error('Failed to update data sharing consent:', error)
      return false
    }
  }

  async issueVerifiableCredential(type: string, issuer: string, credentialData: any): Promise<CarvCredential | null> {
    try {
      if (!this.currentProfile) {
        throw new Error('No CARV profile found')
      }

      const credential: CarvCredential = {
        id: `vc_${Date.now()}_${this.simpleHash(type + issuer)}`,
        type,
        issuer,
        issued_date: new Date().toISOString(),
        credential_data: credentialData,
        verification_status: 'verified'
      }

      this.currentProfile.verifiable_credentials.push(credential)

      // Update localStorage
      if (typeof window !== 'undefined') {
        localStorage.setItem('carv_profile', JSON.stringify(this.currentProfile))
      }

      return credential
    } catch (error) {
      console.error('Failed to issue verifiable credential:', error)
      return null
    }
  }

  async logout(): Promise<void> {
    this.currentProfile = null
    if (typeof window !== 'undefined') {
      localStorage.removeItem('carv_profile')
      localStorage.removeItem('carv_signature')
    }
  }

  // Data sovereignty methods
  async getDataContributions(): Promise<any[]> {
    // This would fetch user's data contributions from CARV Data Protocol
    return []
  }

  async contributeData(dataType: string, data: any, consentLevel: DataSharingConsent['consent_level']): Promise<boolean> {
    try {
      // Verify user consent
      const hasConsent = this.currentProfile?.data_sharing_consents.some(
        consent => consent.data_type === dataType && consent.consent_level !== 'none'
      )

      if (!hasConsent) {
        throw new Error('No consent found for this data type')
      }

      // In a real implementation, this would submit to CARV Data Protocol
      console.log('Contributing data to CARV Protocol:', { dataType, consentLevel })
      return true
    } catch (error) {
      console.error('Failed to contribute data:', error)
      return false
    }
  }
}

// Global instance
export const carvSDK = CarvSDK.getInstance()

// React hooks for CARV integration
export const useCarvAuth = () => {
  const [isAuthenticated, setIsAuthenticated] = React.useState(false)
  const [profile, setProfile] = React.useState<CarvProfile | null>(null)
  const [loading, setLoading] = React.useState(true)
  const [initialized, setInitialized] = React.useState(false)
  const [hydrated, setHydrated] = React.useState(false)

  // Handle hydration
  React.useEffect(() => {
    setHydrated(true)
  }, [])

  React.useEffect(() => {
    const checkAuth = async () => {
      try {
        // Only check localStorage after hydration
        if (!hydrated) {
          setLoading(false)
          setInitialized(true)
          return
        }

        // Check for existing session in localStorage
        const storedAuth = localStorage.getItem('carv_auth_session')
        const storedProfile = localStorage.getItem('carv_profile')
        
        console.log('ðŸ” Checking stored auth:', { storedAuth, hasProfile: !!storedProfile })
        
        if (storedAuth === 'true' && storedProfile) {
          try {
            const profile = JSON.parse(storedProfile)
            setProfile(profile)
            setIsAuthenticated(true)
            console.log('âœ… Restored authentication from localStorage')
          } catch (parseError) {
            console.error('âŒ Failed to parse stored profile:', parseError)
            localStorage.removeItem('carv_auth_session')
            localStorage.removeItem('carv_profile')
            setIsAuthenticated(false)
            setProfile(null)
          }
        } else {
          console.log('âŒ No valid stored authentication found')
          setIsAuthenticated(false)
          setProfile(null)
        }
      } catch (error) {
        console.error('Failed to check CARV auth:', error)
        // Clear any invalid stored auth
        if (typeof window !== 'undefined') {
          localStorage.removeItem('carv_auth_session')
          localStorage.removeItem('carv_profile')
        }
        setIsAuthenticated(false)
        setProfile(null)
      } finally {
        setLoading(false)
        setInitialized(true)
      }
    }

    checkAuth()
  }, [hydrated])

  const login = async () => {
    setLoading(true)
    try {
      // For development, create a mock successful authentication
      const mockProfile: CarvProfile = {
        carv_id: `carv_${Date.now()}`,
        wallet_address: '0x742d35Cc6435C1532C8a7b36F36A3f0b0c2b4567',
        verifiable_credentials: [
          {
            id: 'civic_id_001',
            type: 'Government ID',
            issuer: 'Government Authority',
            issued_date: new Date().toISOString(),
            credential_data: { verified: true },
            verification_status: 'verified' as const
          }
        ],
        data_sharing_consents: [],
        reputation_score: 750,
        is_verified: true
      }
      
      // Store authentication state
      localStorage.setItem('carv_auth_session', 'true')
      localStorage.setItem('carv_profile', JSON.stringify(mockProfile))
      
      setProfile(mockProfile)
      setIsAuthenticated(true)
      
      console.log('âœ… User authenticated successfully')
      
      return { success: true, carv_id: mockProfile.carv_id }
    } catch (error) {
      console.error('Authentication failed:', error)
      return { success: false, error: 'Authentication failed' }
    } finally {
      setLoading(false)
    }
  }

  const logout = async () => {
    // Clear stored authentication
    localStorage.removeItem('carv_auth_session')
    localStorage.removeItem('carv_profile')
    
    setProfile(null)
    setIsAuthenticated(false)
    
    console.log('âœ… User logged out successfully')
  }

  return {
    isAuthenticated,
    profile,
    loading,
    initialized,
    hydrated,
    login,
    logout
  }
}

// Import React for hooks
import React from 'react'

export default carvSDK
